На основе проведенного исследования я дополню ваш проект VO2max Report информацией по оставшимся вопросам: 3D визуализации, экспортным форматам и real-time графикам.
3D визуализации
Matplotlib 3D
Matplotlib предоставляет мощные возможности для 3D визуализации через модуль mplot3d
2
. Для создания 3D surface plot, показывающего взаимосвязь между Power, HR и VO2:




Python
from mpl_toolkits.mplot3d import Axes3D
import matplotlib.pyplot as plt
import numpy as np

def create_3d_surface_plot(items):
    """Создаёт 3D поверхность Power-HR-VO2"""

    # Подготовка данных
    power = [item.power for item in items]
    hr = [item.hr for item in items]
    vo2 = [item.vo2_ml_min for item in items]

    # Создание сетки для интерполяции
    power_grid = np.linspace(min(power), max(power), 20)
    hr_grid = np.linspace(min(hr), max(hr), 20)
    P, H = np.meshgrid(power_grid, hr_grid)

    # Интерполяция VO2 значений
    from scipy.interpolate import griddata
    VO2 = griddata((power, hr), vo2, (P, H), method='cubic')

    # Создание 3D графика
    fig = plt.figure(figsize=(12, 8))
    ax = fig.add_subplot(111, projection='3d')

    # Surface plot с цветовой картой
    surf = ax.plot_surface(P, H, VO2, cmap='viridis', alpha=0.8)

    # Добавление исходных точек данных
    ax.scatter(power, hr, vo2, color='red', s=50, alpha=0.6)

    ax.set_xlabel('Мощность (Вт)')
    ax.set_ylabel('ЧСС (уд/мин)')
    ax.set_zlabel('VO2 (мл/мин)')
    ax.set_title('3D взаимосвязь Power-HR-VO2')

    # Цветовая шкала
    fig.colorbar(surf, shrink=0.5, aspect=5)

    return fig
Matplotlib также поддерживает 3D анимации для вращения графиков
12
16
 и контурные графики в 3D пространстве
6
.

Plotly 3D
Plotly предлагает более интерактивные 3D визуализации
14
15
:




Python
import plotly.graph_objects as go
import numpy as np

def create_interactive_3d_surface(items):
    """Создаёт интерактивный 3D surface plot"""

    power = [item.power for item in items]
    hr = [item.hr for item in items]
    vo2 = [item.vo2_ml_min for item in items]

    # Создание сетки
    power_grid = np.linspace(min(power), max(power), 30)
    hr_grid = np.linspace(min(hr), max(hr), 30)
    P, H = np.meshgrid(power_grid, hr_grid)

    # Интерполяция
    from scipy.interpolate import griddata
    VO2 = griddata((power, hr), vo2, (P, H), method='linear')

    fig = go.Figure(data=[go.Surface(
        x=P, y=H, z=VO2,
        colorscale='Viridis',
        contours=dict(
            x=dict(show=True), 
            y=dict(show=True), 
            z=dict(show=True)
        )
    )])

    # Добавление точек данных
    fig.add_trace(go.Scatter3d(
        x=power, y=hr, z=vo2,
        mode='markers',
        marker=dict(size=5, color='red'),
        name='Измерения'
    ))

    fig.update_layout(
        title='Интерактивная 3D поверхность Power-HR-VO2',
        scene=dict(
            xaxis_title='Мощность (Вт)',
            yaxis_title='ЧСС (уд/мин)',
            zaxis_title='VO2 (мл/мин)'
        )
    )

    return fig
Plotly также поддерживает 3D volume plots для объемной визуализации
5
18
 и animated 3D графики
17
.

Экспорт в SVG и EMF
Matplotlib экспорт
Matplotlib поддерживает прямой экспорт в SVG формат:




Python
# Сохранение как SVG
plt.savefig('chart.svg', format='svg', dpi=300, bbox_inches='tight')
Для экспорта в EMF требуется дополнительная конвертация через Inkscape
8
11
:




Python
import subprocess
import matplotlib.pyplot as plt

def export_to_emf(fig, filename):
    """Экспорт фигуры в EMF через Inkscape"""

    # Сначала сохраняем как SVG
    svg_file = f'{filename}.svg'
    fig.savefig(svg_file, format='svg', bbox_inches='tight')

    # Конвертируем SVG в EMF через Inkscape
    try:
        subprocess.run([
            'inkscape', 
            '--export-filename', f'{filename}.emf',
            svg_file
        ], check=True)
        print(f'EMF файл сохранен как {filename}.emf')
    except subprocess.CalledProcessError as e:
        print(f'Ошибка конвертации: {e}')
Plotly экспорт
Plotly поддерживает экспорт в SVG через библиотеку Kaleido
10
13
:




Python
import plotly.graph_objects as go

fig = go.Figure()
# ... создание графика ...

# Экспорт в SVG
fig.write_image('chart.svg')

# Экспорт в PNG
fig.write_image('chart.png', width=800, height=600, scale=2)
Для EMF формата в Plotly также требуется конвертация через Inkscape
4
19
:




Python
def export_plotly_to_emf(fig, filename):
    """Экспорт Plotly графика в EMF"""

    # Сохраняем как SVG
    svg_file = f'{filename}.svg'
    fig.write_image(svg_file)

    # Конвертируем в EMF
    import subprocess
    subprocess.run([
        'inkscape',
        '--export-filename', f'{filename}.emf',
        svg_file
    ])
Real-time графики с WebSockets
Matplotlib real-time
Для real-time визуализации в matplotlib используется подход с обновлением данных без блокировки кода
1
3
:




Python
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from collections import deque

class RealTimePlot:
    def __init__(self, max_points=100):
        self.fig, self.ax = plt.subplots()
        self.power_data = deque(maxlen=max_points)
        self.hr_data = deque(maxlen=max_points)
        self.line, = self.ax.plot([], [], 'r-')

        self.ax.set_xlabel('Время')
        self.ax.set_ylabel('ЧСС')
        self.ax.set_title('Real-time ЧСС мониторинг')

    def update(self, new_power, new_hr):
        """Обновление данных графика"""
        self.power_data.append(new_power)
        self.hr_data.append(new_hr)

        self.line.set_data(range(len(self.hr_data)), self.hr_data)
        self.ax.relim()
        self.ax.autoscale_view()

        # Обновление без блокировки
        plt.draw()
        plt.pause(0.001)

    def start_animation(self):
        """Запуск анимации"""
        ani = animation.FuncAnimation(
            self.fig, self.animate, interval=1000, blit=False
        )
        plt.show(block=False)

    def animate(self, frame):
        """Функция анимации"""
        if len(self.hr_data) > 0:
            self.line.set_data(range(len(self.hr_data)), self.hr_data)
            self.ax.relim()
            self.ax.autoscale_view()
        return self.line,
Plotly Dash real-time с WebSockets
Plotly Dash поддерживает real-time обновления через WebSockets несколькими способами
7
9
:

Вариант 1: Django Channels с WebSockets



Python
# consumers.py
import json
from channels.generic.websocket import AsyncWebsocketConsumer

class RealTimeDataConsumer(AsyncWebsocketConsumer):
    async def connect(self):
        await self.accept()

    async def receive(self, text_data):
        data = json.loads(text_data)

        # Отправка данных всем подключенным клиентам
        await self.channel_layer.group_send(
            'realtime_data',
            {
                'type': 'data_update',
                'message': data
            }
        )

    async def data_update(self, event):
        await self.send(text_data=json.dumps(event['message']))

# Dash app с WebSocket компонентом
import dash
from dash_extensions.enrich import Dash, Input, Output, WebSocket
import plotly.graph_objects as go

app = Dash(prevent_initial_callbacks=True)

app.layout = dash.html.Div([
    dash.html.H1('Real-time VO2 мониторинг'),
    WebSocket(id='ws', url='ws://localhost:8000/ws/realtime/'),
    dcc.Graph(id='live-graph'),
    dcc.Interval(id='interval', interval=1000)
])

@app.callback(
    Output('live-graph', 'figure'),
    Input('ws', 'message'),
    Input('interval', 'n_intervals')
)
def update_graph(ws_message, n):
    # Обработка WebSocket сообщений
    if ws_message:
        data = json.loads(ws_message['data'])
        # Обновление графика с новыми данными
        pass

    return create_live_figure()
Вариант 2: Dash с Server-Sent Events



Python
from dash_extensions.enrich import Dash, Input, Output, Serverside

app = Dash(prevent_initial_callbacks=True)

app.layout = html.Div([
    html.H1('Real-time мониторинг'),
    dcc.Graph(id='live-graph'),
    dcc.Interval(id='interval', interval=1000),
    Serverside(id('store')
])

@app.callback(
    Output('store', 'data'),
    Input('interval', 'n_intervals')
)
def update_data(n):
    # Получение данных из внешнего источника
    return get_latest_measurements()

@app.callback(
    Output('live-graph', 'figure'),
    Input('store', 'data')
)
def update_graph(data):
    if data:
        fig = go.Figure()
        fig.add_trace(go.Scatter(
            x=data['time'],
            y=data['hr'],
            mode='lines+markers',
            name='ЧСС'
        ))
        return fig
    return go.Figure()
Вариант 3: Интеграция с FastAPI WebSocket



Python
# FastAPI WebSocket сервер
from fastapi import WebSocket, FastAPI
import json

app = FastAPI()

@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    await websocket.accept()
    while True:
        # Получение данных от оборудования
        data = await get_measurement_data()
        await websocket.send_text(json.dumps(data))

# Dash клиент
import asyncio
import websockets
import threading

class WebSocketClient:
    def __init__(self, dash_app):
        self.dash_app = dash_app
        self.data_buffer = []

    async def connect(self):
        async with websockets.connect('ws://localhost:8000/ws') as ws:
            while True:
                data = await ws.recv()
                self.data_buffer.append(json.loads(data))

    def start_client(self):
        thread = threading.Thread(target=lambda: asyncio.run(self.connect()))
        thread.daemon = True
        thread.start()
Оптимизации для real-time графиков
Буферизация данных: Используйте deque с ограниченным размером для предотвращения утечек памяти
1

Throttling обновлений: Ограничьте частоту обновлений до разумных значений (1-5 секунд)

Асинхронная обработка: Используйте асинхронные операции для получения данных

Оптимизация рендеринга: Для matplotlib используйте blit=True в анимации для улучшения производительности

Рекомендации для VO2max Report
Для статических отчётов: Используйте Matplotlib с экспортом в SVG/EMF для максимального качества в документах

Для веб-интерфейса: Plotly Dash с WebSocket интеграцией для real-time мониторинга

3D визуализации: Добавьте как дополнительную функцию для анализа взаимосвязей между параметрами

Экспортные форматы: Предоставьте опции экспорта в SVG (для веб), EMF (для Word), PNG (для быстрого просмотра)

Эти расширения значительно улучшат функциональность вашей системы VO2max Report, предоставив как продвинутые инструменты анализа, так и возможности реального времени для мониторинга тренировок.